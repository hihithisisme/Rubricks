global Color {
    // BGR
    const RED = h00DD00;
    const GREEN = h0000DD;
    const BLUE = hDD0000;
    const YELLOW = h008888;
    const WHITE = h888888;
    const BLACK = h000000;
}

module mojo_top (
        input clk,                  // 50MHz clock
        // input rst_n,
        output led [8],             // 8 user controllable LEDs
        output spi_miso,            // AVR SPI MISO
        output spi_channel [4],     // AVR general purpose pins (used by default to select ADC channel)
        output avr_rx,              // AVR RX (FPGA TX)
        output led_data[3],
        input user_button[1],
        output io_led [3][8],   // LEDs on IO Shield
        output io_seg [8],      // 7-segment LEDs on IO Shield
        output io_sel [4],      // Digit select on IO Shield
        input io_button [5],    // 5 buttons on IO Shield
        input io_dip [3][8]     // DIP switches on IO Shield
    ) {
  
    sig rst;    // reset signal
    sig control_ra[4];
    sig control_rb[4];
    sig control_wa[4];
    sig wdsel;
    alu myALU;
    reg_file myReg;
    // led_matrix and init_blk are hardcoded, 
    // need to change if these constants change
    const ROWS = 8;
    const COLS = 3;


    .clk(clk) {
        reset_conditioner reset_cond;
        button_conditioner button_cond;
        edge_detector edge (#RISE(1), #FALL(0));
        .rst(rst){
        counter caseCount (#SIZE(8), #DIV(25));
        }
        dff reset;
        dff color1[24];
        dff color2[24];
        dff led_matrix_temp[COLS][ROWS];
        .rst(rst) {
            led_matrix led_matrix(#ROWS(ROWS), #COLS(COLS)); 
        }
    }

    always {
    
        reset_cond.in = reset.q;
        rst = reset_cond.out;
    
        led = 8h00;                 // turn LEDs off
        spi_miso = bz;              // not using SPI
        spi_channel = bzzzz;        // not using flags
        avr_rx = bz;                // not using serial port
        io_led = 3x{{8h00}};    // turn LEDs off
        io_seg = 8hff;          // turn segments off
        io_sel = 4hf;           // select no digits
    
        edge.in = button_cond.out;
        button_cond.in = io_button[1];
        
        
        // testing register files
        myReg.clk = clk;  // connect reg_file clk to a slower clock to observe changes
        control_ra = 3;
        control_rb = 6;
        if(io_dip[2][1] == 1) control_wa = 6;
        else control_wa = 3;
        myALU.alufn = io_dip[2][7:2];
        wdsel = edge.out;
    
        myReg.wa = control_wa;
        myReg.wdsel = wdsel;
        myReg.ra_address = control_ra;
        myReg.rb_address = control_rb;
        
        myALU.a = myReg.ra_data;
        if(io_dip[2][0] == 1)
          myALU.b = 1;
        else myALU.b = myReg.rb_data;
        
        myReg.wd = myALU.out;
    
        io_led[0] = myReg.test0;
        io_led[1] = myReg.test1;
        io_led[2] = myALU.out;
    
    
    
        
        //first we attach nodes
        led_matrix.color1 = color1.q;
        led_matrix.color2 = color2.q;
        led_matrix.matrix = led_matrix_temp.q;
        led_data = led_matrix.led_data;
    
        
        led_matrix_temp.d[0] = caseCount.value;
        led_matrix_temp.d[1] = caseCount.value;
        led_matrix_temp.d[2] = caseCount.value;
        
        color1.d = Color.RED;
        color2.d = Color.BLUE;
    
        if(user_button[0]==1){
          color1.d = Color.GREEN;
          color2.d = Color.YELLOW;
        }
    
         
        
        //to change, assign color.d to whatever color we want
        //for reference, take a look at rom_screen_idle
    
        if(io_button[0]==1){
          color1.d = Color.YELLOW;
          color2.d = Color.GREEN;
        }
    
    }
}
